/*
 * kairq.c
 *
 *  Created on: Dec 27, 2014
 *      Author: kamichal
 */

/* ============================================================================
 * Copyright (c) 2008-2012 Texas Instruments Incorporated.
 * Except for those rights granted to you in your license from TI, all rights
 * reserved.
 *
 * Software License Agreement
 * Texas Instruments (TI) is supplying this software for use solely and
 * exclusively on TI devices. The software is owned by TI and/or its suppliers,
 * and is protected under applicable patent and copyright laws.  You may not
 * combine this software with any open-source software if such combination would
 * cause this software to become subject to any of the license terms applicable
 * to such open source software.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
 * NO WARRANTIES APPLY TO THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY.
 * EXAMPLES OF EXCLUDED WARRANTIES ARE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE AND WARRANTIES OF NON-INFRINGEMENT,
 * BUT ALL OTHER WARRANTY EXCLUSIONS ALSO APPLY. FURTHERMORE, TI SHALL NOT,
 * UNDER ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, CONSEQUENTIAL
 * OR PUNITIVE DAMAGES, FOR ANY REASON WHATSOEVER.
 * ============================================================================
 */

/** @file intc_example.c
 *
 *  @brief INTC functional layer sample source file for SAR
 *
 *
 * \page    page7  INTC EXAMPLE DOCUMENTATION
 *
 * \section INTC   INTC EXAMPLE
 *
 * \subsection INTCx    TEST DESCRIPTION:
 *      This test verifies the functionality of CSL INTC module. INTC module
 * is used to configure and enable/disable the interrupts available on the
 * C5515/C5517 DSP.
 *
 * This test verifies the INTC module using CSL SAR. SAR module on C5515/C5517
 * DSP is used to convert the voltage generated by the key pad available on the
 * C5515/C5517 EVM to digital values. During the test C5515/C5517 EVM key pad
 * button voltage is read using interrupts. SAR interrupts are configured and
 * ISR is registered using INTC module APIs. SAR is configured and the data
 * conversion is started using SAR_startConversion(). Interrupt is generated
 * when there is a valid value in the SAR data register. Digital value is read
 * from the SAR data register using the Interrupt Service Routine and is
 * displayed in the CCS 'stdout' window. Generation of SAR interrupt will prove
 * the functionality of INTC module.
 *
 * Digital values corresponding to the button voltage will vary slightly
 * depending on the system clock value. Below are the range of values for
 * each button available on the C5515/C5517 EVM key pad.
 *
 *  No button pushed: 0x3fb - 0x3ff
 *  SHIFT:    0x230 - 0x238
 *  STOP:     0x0
 *  RWD:      0x20f - 0x216
 *  MENU:     0x367 - 0x376
 *  DN:       0x2bc - 0x2c7
 *  SEL/PLAY: 0x1d3 - 0x1d8
 *  UP:       0x24f - 0x258
 *  REC:      0xd5  - 0xd8
 *  FWD:      0x163 - 0x167
 *  MODE:     0x30b - 0x318
 *
 * NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5515 AND
 * C5517. MAKE SURE THAT PROPER PROPER CHIP VERSION MACRO SHOULD IS DEFINED
 * IN THE FILE c55xx_csl\inc\csl_general.h.
 *
 * \subsection INTCy    TEST PROCEDURE:
 *  @li Open the CCS and connect the target (C5515 EVM or C5517)
 *  @li Open the project "CSL_INTC_Example.pjt" and build it
 *  @li Load the program on to the target
 *  @li Set the PLL frequency to 12.288MHz
 *  @li Press any one of the buttons present on C5515/C5517 EVM key pad.
 *  @li Run the program and observe the test result
 *  @li Repeat the test at the following PLL frequencies
 *      C5515: 60MHz and 100MHz
 *      C5517: 60MHz, 100MHz, 150MHz and 200MHz
 *  @li Repeat the test in Release mode
 *
 * \subsection INTCz    TEST RESULT:
 *  @li All the CSL APIs should return success
 *  @li Digital value should read in the ISR and displayed in the CCS "stdout"
 *      window
 *
 *
 */

/* ============================================================================
 * Revision History
 * ================
 * 22-Sep-2008  Created
 * 10-Jul-2012  Added C5517 Compatibility
 * 28-Dec-2014  Kamichal's refactor and development
 * ============================================================================
 */

#include <csl_sar.h>
#include <csl_intc.h>
#include <csl_general.h>
#include <stdio.h>
#include <stdint.h>
#include <ka_pp.h>

#include "kairq.h"

#define CSL_TEST_FAILED         (1)
#define CSL_TEST_PASSED         (0)

/* Global Structure Declaration*/

/** Sar object structure */
CSL_SarHandleObj SarObj;
/** Sar object pointer */
CSL_SarHandleObj *SarHandle;
/* SAR A/D Data Register Address */
Uint32 sarRegDataAddr = 0x7014;

Uint16 readBuffer;
volatile int g_counter = 0;

//---------Function prototypes---------
/** Interrupt Service Routine */
interrupt void sarISR(void);

/* Reference the start of the interrupt vector table */
/* This symbol is defined in file vectors.asm       */
extern void VECSTART(void);

/////INSTRUMENTATION FOR BATCH TESTING -- Part 1 --
/////  Define PaSs_StAtE variable for catching errors as program executes.
/////  Define PaSs flag for holding final pass/fail result at program completion.
volatile Int16 PaSs_StAtE = 0x0001; // Init to 1. Reset to 0 at any monitored execution error.
volatile Int16 PaSs = 0x0000; // Init to 0.  Updated later with PaSs_StAtE when and if
/////                                  program flow reaches expected exit point(s).
/////

#define expect_CSL_TEST_PASSED(fcn_call) expect_match_ret_msg(fcn_call, CSL_TEST_PASSED, " KAIRQ TEST FAILED ", CSL_TEST_FAILED)

#define expect_CSL_SOK(fcn_call) expect_match_ret_msg(fcn_call, CSL_SOK, " KAIRQ TEST FAILED ", CSL_TEST_FAILED)



int init_irq_app(void)
{
    Bool flag = 1;

    int chanNo;

    printf("Testing INTC using SAR module\n");
    printf("Press Any Button on the EVM Keypad\n");

    /* Disable interrupt */
    IRQ_globalDisable();

    /* Clear any pending interrupts */
    IRQ_clearAll();

    /* Disable all the interrupts */
    IRQ_disableAll();

    /* Initialize Interrupt Vector table */
    IRQ_setVecs((Uint32) (&VECSTART));

    /* IRQ init call*/
    IRQ_init((CSL_IRQ_Dispatch*) 0x0000, 0);

    {
        CSL_IRQ_Config irqConfig;
        CSL_IRQ_Config irqQuery;

        /* IRQ_config */
        irqConfig.funcAddr = &sarISR;
        irqConfig.funcArg = 2;

        IRQ_config(SAR_EVENT, &irqConfig);

        /* Getconfig */
        IRQ_getConfig(SAR_EVENT, &irqQuery);

        if (irqQuery.funcAddr != irqConfig.funcAddr)
        {
            printf("Wrong ISR address\n");
        }
    }

    /* Initialize the SAR module */
    expect_CSL_SOK(SAR_init())

    /* Open SAR channel */
    expect_CSL_SOK(SAR_chanOpen(&SarObj, CSL_SAR_CHAN_3))

    SarHandle = &SarObj;

    /* Initialize channel */
    expect_CSL_SOK(SAR_chanInit(SarHandle))

    /* Clear any pending Interrupt */
    IRQ_clear(SAR_EVENT);
    IRQ_test(SAR_EVENT, &flag);
    IRQ_map(SAR_EVENT);
    /* Set Arguments */
    expect_CSL_SOK(IRQ_setArg(SAR_EVENT, sarRegDataAddr))

    /* Register the ISR */
    IRQ_plug(SAR_EVENT, &sarISR);

    {
        CSL_SarChSetup param;
        param.OpMode = CSL_SAR_INTERRUPT;
        param.MultiCh = CSL_SAR_NO_DISCHARGE;
        param.RefVoltage = CSL_SAR_REF_VIN;
        param.SysClkDiv = 0x0b;
        /* Configuration for SAR module */
        expect_CSL_SOK(SAR_chanSetup(SarHandle, &param))
    }

    /* Set channel cycle set */
    expect_CSL_SOK(SAR_chanCycSet(SarHandle, CSL_SAR_SINGLE_CONVERSION))

    /* set ADC Measurement parameters */
    expect_CSL_SOK(SAR_A2DMeasParamSet(SarHandle, CSL_KEYPAD_MEAS, &chanNo))

    /* Enabling Interrupt */
    IRQ_enable(SAR_EVENT);
    IRQ_globalEnable();


    return CSL_TEST_PASSED;
}

int deinit_SAR(CSL_SarHandleObj *sar_handle)
{
    /* Stop the conversion */
    expect_CSL_SOK(SAR_stopConversion(sar_handle))
    /* Close the channel */
    expect_CSL_SOK(SAR_chanClose(sar_handle))
    /* Deinit */
    expect_CSL_SOK(SAR_deInit())
    return CSL_TEST_PASSED;
}


/* Testing of SAR A/D Keypad Voltage Measurement */
int sar_interupt_test(void)
{
    expect_CSL_TEST_PASSED(init_irq_app())
    expect_CSL_SOK(SAR_startConversion(SarHandle))

    while (g_counter !=0)
        ;

    printf("After ISR :SAR ADC read data 0x%x\n", readBuffer);

    expect_CSL_TEST_PASSED(deinit_SAR(SarHandle))

    printf("SAR interrupt test returns.\n");

    return CSL_TEST_PASSED;
}


// ISR to read ADC data
interrupt void sarISR(void)
{
    Uint32 RegAddr;
    g_counter = 0;
    /* Get Arguments which was set using IRQ_setArg */
    IRQ_getArg(SAR_EVENT, &RegAddr);

    if (RegAddr != sarRegDataAddr)
    {
        printf("IRQ_getArg is failed\n");
        /////INSTRUMENTATION FOR BATCH TESTING -- Part 2 --
        /////  Reseting PaSs_StAtE to 0 if error detected here.
        PaSs_StAtE = 0x0000; // Was intialized to 1 at declaration.
        /////
    }

    SAR_readData(SarHandle, &readBuffer);

    printf("SAR triggs an interrupt # %d!, read: %d\n", g_counter, readBuffer);

    g_counter++;

//    if(g_counter > 10)
        IRQ_disable(SAR_EVENT);
}
